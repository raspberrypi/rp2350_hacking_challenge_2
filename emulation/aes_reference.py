#!/usr/bin/env python3
"""
Python AES-256 CTR Mode Reference Implementation

Uses standard Python AES (via pycryptodome or cryptography) for comparison
with the assembly implementation.
"""

import os
import struct

try:
    from Crypto.Cipher import AES
    USE_PYCRYPTODOME = True
except ImportError:
    try:
        from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
        from cryptography.hazmat.backends import default_backend
        USE_PYCRYPTODOME = False
    except ImportError:
        raise ImportError("Please install pycryptodome or cryptography: pip install pycryptodome")


def aes_ctr_encrypt_block(key: bytes, iv: bytes, block_num: int) -> bytes:
    """
    Encrypt a single block counter value using AES-256 ECB.
    
    In CTR mode, the keystream is generated by encrypting IV XOR block_num.
    The assembly uses IV XOR block_num (not IV + block_num as in standard CTR).
    
    Args:
        key: 32-byte AES-256 key
        iv: 16-byte initialization vector
        block_num: Block number (counter)
    
    Returns:
        16-byte encrypted counter block (keystream)
    """
    # Build counter block: IV XOR block_number (big-endian in last word)
    # The assembly does: rev r0,r12; eor r7,r7,r0 (XOR reversed block_num into IV word 3)
    counter_block = bytearray(iv)
    block_num_be = struct.pack('>I', block_num)
    for i in range(4):
        counter_block[12 + i] ^= block_num_be[i]
    
    if USE_PYCRYPTODOME:
        cipher = AES.new(key, AES.MODE_ECB)
        return cipher.encrypt(bytes(counter_block))
    else:
        cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())
        encryptor = cipher.encryptor()
        return encryptor.update(bytes(counter_block)) + encryptor.finalize()


def aes_ctr_decrypt(key: bytes, iv: bytes, ciphertext: bytes) -> bytes:
    """
    Decrypt data using AES-256 CTR mode.
    
    Args:
        key: 32-byte AES-256 key
        iv: 16-byte initialization vector  
        ciphertext: Data to decrypt (must be multiple of 16 bytes)
    
    Returns:
        Decrypted plaintext
    """
    if len(key) != 32:
        raise ValueError("Key must be 32 bytes for AES-256")
    if len(iv) != 16:
        raise ValueError("IV must be 16 bytes")
    if len(ciphertext) % 16 != 0:
        raise ValueError("Ciphertext must be multiple of 16 bytes")
    
    num_blocks = len(ciphertext) // 16
    plaintext = bytearray()
    
    for block_num in range(num_blocks):
        # Get keystream block
        keystream = aes_ctr_encrypt_block(key, iv, block_num)
        
        # XOR with ciphertext to get plaintext
        ct_block = ciphertext[block_num * 16:(block_num + 1) * 16]
        pt_block = bytes(a ^ b for a, b in zip(ct_block, keystream))
        plaintext.extend(pt_block)
    
    return bytes(plaintext)


def aes_ctr_encrypt(key: bytes, iv: bytes, plaintext: bytes) -> bytes:
    """
    Encrypt data using AES-256 CTR mode.
    
    CTR mode encryption and decryption are the same operation.
    
    Args:
        key: 32-byte AES-256 key
        iv: 16-byte initialization vector
        plaintext: Data to encrypt (must be multiple of 16 bytes)
    
    Returns:
        Encrypted ciphertext
    """
    return aes_ctr_decrypt(key, iv, plaintext)


def test_reference():
    """Test the reference implementation"""
    print("Testing AES-256 CTR Reference Implementation...")
    
    # Test with all zeros
    key = b'\x00' * 32
    iv = b'\x00' * 16
    ciphertext = b'\x00' * 16
    
    plaintext = aes_ctr_decrypt(key, iv, ciphertext)
    print(f"Key: {key.hex()}")
    print(f"IV: {iv.hex()}")
    print(f"Ciphertext: {ciphertext.hex()}")
    print(f"Plaintext: {plaintext.hex()}")
    
    # Verify that encrypt(decrypt(x)) == x
    re_encrypted = aes_ctr_encrypt(key, iv, plaintext)
    assert re_encrypted == ciphertext, "Round-trip failed!"
    print("Round-trip test passed!")


if __name__ == '__main__':
    test_reference()
